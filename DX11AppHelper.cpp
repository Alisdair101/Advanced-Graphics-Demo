#include "DX11AppHelper.h"

HINSTANCE DX11AppHelper::_hInst = nullptr;
HWND DX11AppHelper::_hWnd = nullptr;
D3D_DRIVER_TYPE DX11AppHelper::_pDriverType = D3D_DRIVER_TYPE_NULL;
D3D_FEATURE_LEVEL DX11AppHelper::_pFeatureLevel = D3D_FEATURE_LEVEL_11_0;
ID3D11Device* DX11AppHelper::_pd3dDevice = nullptr;
ID3D11DeviceContext* DX11AppHelper::_pImmediateContext = nullptr;
IDXGISwapChain* DX11AppHelper::_pSwapChain = nullptr;

ID3D11Buffer* DX11AppHelper::_pVertexBuffer = nullptr;
ID3D11Buffer* DX11AppHelper::_pIndexBuffer = nullptr;
ID3D11Buffer* DX11AppHelper::_pPlaneVertexBuffer = nullptr;
ID3D11Buffer* DX11AppHelper::_pPlaneIndexBuffer = nullptr;
ID3D11Buffer* DX11AppHelper::_pConstantBuffer = nullptr;
ID3D11Buffer* DX11AppHelper::_pSMConstantBuffer = nullptr;

ID3D11DepthStencilState* DX11AppHelper::_pDSLessEqual = nullptr;
ID3D11RasterizerState* DX11AppHelper::_pRSCullNone = nullptr;
ID3D11RasterizerState* DX11AppHelper::_pCCWcullMode = nullptr;
ID3D11RasterizerState* DX11AppHelper::_pCWcullMode = nullptr;

UINT DX11AppHelper::_pWindowHeight;
UINT DX11AppHelper::_pWindowWidth;

UINT DX11AppHelper::_pRenderHeight = 1080;
UINT DX11AppHelper::_pRenderWidth = 1920;

DX11AppHelper::DX11AppHelper()
{
}

DX11AppHelper::~DX11AppHelper()
{
}

LRESULT CALLBACK WndProc(HWND hWnd, UINT message, WPARAM wParam, LPARAM lParam)
{
	PAINTSTRUCT ps;
	HDC hdc;

	switch (message)
	{
	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);
		EndPaint(hWnd, &ps);
		break;

	case WM_DESTROY:
		PostQuitMessage(0);
		break;

	default:
		return DefWindowProc(hWnd, message, wParam, lParam);
	}

	return 0;
}

HRESULT DX11AppHelper::InitWindow(HINSTANCE hInstance, int nCmdShow)
{
	RECT desktop;
	// Get a handle to the desktop window
	const HWND hDesktop = GetDesktopWindow();
	// Get the size of screen to the variable desktop
	GetWindowRect(hDesktop, &desktop);
	// The top left corner will have coordinates (0,0)
	// and the bottom right corner will have coordinates
	// (horizontal, vertical)
	_pRenderWidth = desktop.right;
	_pRenderHeight = desktop.bottom;

	// Register class
	WNDCLASSEX wcex;
	wcex.cbSize = sizeof(WNDCLASSEX);
	wcex.style = CS_HREDRAW | CS_VREDRAW;
	wcex.lpfnWndProc = WndProc;
	wcex.cbClsExtra = 0;
	wcex.cbWndExtra = 0;
	wcex.hInstance = hInstance;
	wcex.hIcon = LoadIcon(hInstance, (LPCTSTR)IDI_TUTORIAL1);
	wcex.hCursor = LoadCursor(NULL, IDC_ARROW);
	wcex.hbrBackground = (HBRUSH)(COLOR_WINDOW + 1);
	wcex.lpszMenuName = nullptr;
	wcex.lpszClassName = L"TutorialWindowClass";
	wcex.hIconSm = LoadIcon(wcex.hInstance, (LPCTSTR)IDI_TUTORIAL1);
	if (!RegisterClassEx(&wcex))
		return E_FAIL;

	// Create window
	_hInst = hInstance;
	RECT rc = { 0, 0, _pRenderWidth, _pRenderHeight };
	AdjustWindowRect(&rc, WS_OVERLAPPEDWINDOW, FALSE);
	_hWnd = CreateWindow(L"TutorialWindowClass", L"FGGC Semester 2 Framework", WS_OVERLAPPEDWINDOW,
		CW_USEDEFAULT, CW_USEDEFAULT, rc.right - rc.left, rc.bottom - rc.top, nullptr, nullptr, hInstance,
		nullptr);
	if (!_hWnd)
		return E_FAIL;

	ShowWindow(_hWnd, nCmdShow);

	GetClientRect(_hWnd, &rc);
	_pWindowWidth = rc.right - rc.left;
	_pWindowHeight = rc.bottom - rc.top;

	return S_OK;
}

HRESULT DX11AppHelper::InitDevice()
{
	HRESULT hr = S_OK;

	UINT createDeviceFlags = 0;

#ifdef _DEBUG
	createDeviceFlags |= D3D11_CREATE_DEVICE_DEBUG;
#endif

	D3D_DRIVER_TYPE driverTypes[] =
	{
		D3D_DRIVER_TYPE_HARDWARE,
		D3D_DRIVER_TYPE_WARP,
		D3D_DRIVER_TYPE_REFERENCE,
	};

	UINT numDriverTypes = ARRAYSIZE(driverTypes);

	D3D_FEATURE_LEVEL featureLevels[] =
	{
		D3D_FEATURE_LEVEL_11_0,
		D3D_FEATURE_LEVEL_10_1,
		D3D_FEATURE_LEVEL_10_0,
	};

	UINT numFeatureLevels = ARRAYSIZE(featureLevels);

	UINT sampleCount = 4;

	DXGI_SWAP_CHAIN_DESC sd;
	ZeroMemory(&sd, sizeof(sd));
	sd.BufferCount = 1;
	sd.BufferDesc.Width = _pRenderWidth;
	sd.BufferDesc.Height = _pRenderHeight;
	sd.BufferDesc.Format = DXGI_FORMAT_R8G8B8A8_UNORM;
	sd.BufferDesc.RefreshRate.Numerator = 60;
	sd.BufferDesc.RefreshRate.Denominator = 1;
	sd.BufferUsage = DXGI_USAGE_RENDER_TARGET_OUTPUT;
	sd.OutputWindow = _hWnd;
	sd.SampleDesc.Count = sampleCount;
	sd.SampleDesc.Quality = 0;
	sd.Windowed = TRUE;

	for (UINT driverTypeIndex = 0; driverTypeIndex < numDriverTypes; driverTypeIndex++)
	{
		_pDriverType = driverTypes[driverTypeIndex];
		hr = D3D11CreateDeviceAndSwapChain(nullptr, _pDriverType, nullptr, createDeviceFlags, featureLevels, numFeatureLevels,
			D3D11_SDK_VERSION, &sd, &_pSwapChain, &_pd3dDevice, &_pFeatureLevel, &_pImmediateContext);
		if (SUCCEEDED(hr))
			break;
	}

	_pSwapChain->SetFullscreenState(true, NULL);

	if (FAILED(hr))
		return hr;

#pragma endregion

	hr = InitConstantBuffers();

	if (FAILED(hr))
		return hr;

	// Setup the viewport
	D3D11_VIEWPORT vp;
	vp.Width = (FLOAT)_pRenderWidth;
	vp.Height = (FLOAT)_pRenderHeight;
	vp.MinDepth = 0.0f;
	vp.MaxDepth = 1.0f;
	vp.TopLeftX = 0;
	vp.TopLeftY = 0;
	_pImmediateContext->RSSetViewports(1, &vp);

	InitVertexBuffer();
	InitIndexBuffer();

	// Set primitive topology
	_pImmediateContext->IASetPrimitiveTopology(D3D11_PRIMITIVE_TOPOLOGY_TRIANGLELIST);

	hr = InitConstantBuffers();

	return hr;
}


HRESULT DX11AppHelper::InitVertexBuffer()
{
	HRESULT hr;

#pragma region Create Cube Vertex Buffer

	// Frank Luna Normals and Tangents
	SimpleVertex vertices[] =
	{
		// Top Face
		{ XMFLOAT3(-1.0f, 1.0f, -1.0f),		XMFLOAT3(0.0f, 1.0f, 0.0f),		XMFLOAT2(1.0f, 0.0f),  XMFLOAT3(-1.0f, 0.0f, 0.0f) },	// 0
		{ XMFLOAT3(1.0f, 1.0f, -1.0f),		XMFLOAT3(0.0f, 1.0f, 0.0f),		XMFLOAT2(0.0f, 0.0f),  XMFLOAT3(-1.0f, 0.0f, 0.0f) },	// 1
		{ XMFLOAT3(1.0f, 1.0f, 1.0f),		XMFLOAT3(0.0f, 1.0f, 0.0f),		XMFLOAT2(0.0f, 1.0f),  XMFLOAT3(-1.0f, 0.0f, 0.0f) },	// 2
		{ XMFLOAT3(-1.0f, 1.0f, 1.0f),		XMFLOAT3(0.0f, 1.0f, 0.0f),		XMFLOAT2(1.0f, 1.0f),  XMFLOAT3(-1.0f, 0.0f, 0.0f) },	// 3

																																	// Bottom Face
		{ XMFLOAT3(-1.0f, -1.0f, -1.0f),	XMFLOAT3(0.0f, 1.0f, 0.0f),		XMFLOAT2(0.0f, 0.0f),  XMFLOAT3(1.0f, 0.0f, 0.0f) },	// 4
		{ XMFLOAT3(1.0f, -1.0f, -1.0f),		XMFLOAT3(0.0f, 1.0f, 0.0f),		XMFLOAT2(1.0f, 0.0f),  XMFLOAT3(1.0f, 0.0f, 0.0f) },	// 5
		{ XMFLOAT3(1.0f, -1.0f, 1.0f),		XMFLOAT3(0.0f, 1.0f, 0.0f),		XMFLOAT2(1.0f, 1.0f),  XMFLOAT3(1.0f, 0.0f, 0.0f) },	// 6
		{ XMFLOAT3(-1.0f, -1.0f, 1.0f),		XMFLOAT3(0.0f, 1.0f, 0.0f),		XMFLOAT2(0.0f, 1.0f),  XMFLOAT3(1.0f, 0.0f, 0.0f) },	// 7

																																	// Left Face
		{ XMFLOAT3(-1.0f, -1.0f, 1.0f),		XMFLOAT3(-1.0f, 0.0f, 0.0f),	XMFLOAT2(0.0f, 1.0f),  XMFLOAT3(0.0f, 0.0f, -1.0f) },	// 8
		{ XMFLOAT3(-1.0f, -1.0f, -1.0f),	XMFLOAT3(-1.0f, 0.0f, 0.0f),	XMFLOAT2(1.0f, 1.0f),  XMFLOAT3(0.0f, 0.0f, -1.0f) },	// 9
		{ XMFLOAT3(-1.0f, 1.0f, -1.0f),		XMFLOAT3(-1.0f, 0.0f, 0.0f),	XMFLOAT2(1.0f, 0.0f),  XMFLOAT3(0.0f, 0.0f, -1.0f) },	// 10
		{ XMFLOAT3(-1.0f, 1.0f, 1.0f),		XMFLOAT3(-1.0f, 0.0f, 0.0f),	XMFLOAT2(0.0f, 0.0f),  XMFLOAT3(0.0f, 0.0f, -1.0f) },	// 11

																																	// Right Face
		{ XMFLOAT3(1.0f, -1.0f, 1.0f),		XMFLOAT3(1.0f, 0.0f, 0.0f),		XMFLOAT2(1.0f, 1.0f),  XMFLOAT3(0.0f, 0.0f, 1.0f) },	// 12
		{ XMFLOAT3(1.0f, -1.0f, -1.0f),		XMFLOAT3(1.0f, 0.0f, 0.0f),		XMFLOAT2(0.0f, 1.0f),  XMFLOAT3(0.0f, 0.0f, 1.0f) },	// 13
		{ XMFLOAT3(1.0f, 1.0f, -1.0f),		XMFLOAT3(1.0f, 0.0f, 0.0f),		XMFLOAT2(0.0f, 0.0f),  XMFLOAT3(0.0f, 0.0f, 1.0f) },	// 14
		{ XMFLOAT3(1.0f, 1.0f, 1.0f),		XMFLOAT3(1.0f, 0.0f, 0.0f),		XMFLOAT2(1.0f, 0.0f),  XMFLOAT3(0.0f, 0.0f, 1.0f) },	// 15

																																	// Front Face
		{ XMFLOAT3(-1.0f, -1.0f, -1.0f),	XMFLOAT3(0.0f, 0.0f, -1.0f),	XMFLOAT2(0.0f, 1.0f),  XMFLOAT3(1.0f, 0.0f, 0.0f) },	// 16
		{ XMFLOAT3(1.0f, -1.0f, -1.0f),		XMFLOAT3(0.0f, 0.0f, -1.0f),	XMFLOAT2(1.0f, 1.0f),  XMFLOAT3(1.0f, 0.0f, 0.0f) },	// 17
		{ XMFLOAT3(1.0f, 1.0f, -1.0f),		XMFLOAT3(0.0f, 0.0f, -1.0f),	XMFLOAT2(1.0f, 0.0f),  XMFLOAT3(1.0f, 0.0f, 0.0f) },	// 18
		{ XMFLOAT3(-1.0f, 1.0f, -1.0f),		XMFLOAT3(0.0f, 0.0f, -1.0f),	XMFLOAT2(0.0f, 0.0f),  XMFLOAT3(1.0f, 0.0f, 0.0f) },	// 19

																																	// Back Face
		{ XMFLOAT3(-1.0f, -1.0f, 1.0f),		XMFLOAT3(0.0f, 0.0f, 1.0f),		XMFLOAT2(1.0f, 1.0f),  XMFLOAT3(-1.0f, 0.0f, 0.0f) },	// 20
		{ XMFLOAT3(1.0f, -1.0f, 1.0f),		XMFLOAT3(0.0f, 0.0f, 1.0f),		XMFLOAT2(0.0f, 1.0f),  XMFLOAT3(-1.0f, 0.0f, 0.0f) },	// 21
		{ XMFLOAT3(1.0f, 1.0f, 1.0f),		XMFLOAT3(0.0f, 0.0f, 1.0f),		XMFLOAT2(0.0f, 0.0f),  XMFLOAT3(-1.0f, 0.0f, 0.0f) },	// 22
		{ XMFLOAT3(-1.0f, 1.0f, 1.0f),		XMFLOAT3(0.0f, 0.0f, 1.0f),		XMFLOAT2(1.0f, 0.0f),  XMFLOAT3(-1.0f, 0.0f, 0.0f) },	// 23
	};

	D3D11_BUFFER_DESC bd;
	ZeroMemory(&bd, sizeof(bd));
	bd.Usage = D3D11_USAGE_DEFAULT;
	bd.ByteWidth = sizeof(SimpleVertex) * 24;
	bd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	bd.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA InitData;
	ZeroMemory(&InitData, sizeof(InitData));
	InitData.pSysMem = vertices;

	hr = _pd3dDevice->CreateBuffer(&bd, &InitData, &_pVertexBuffer);

	if (FAILED(hr))
		return hr;

#pragma endregion

#pragma region Create Plane Vertex Bufffer

	// Create Plane vertex buffer
	SimpleVertex planeVertices[] =
	{
		{ XMFLOAT3(-1.0f, -1.0f, 0.0f), XMFLOAT3(-1.0f, -1.0f, 0.0f),	XMFLOAT2(0.0f, 5.0f), XMFLOAT3(-1.0f, 0.0f, 0.0f) },
		{ XMFLOAT3(1.0f, -1.0f, 0.0f),	XMFLOAT3(1.0f, -1.0f, 0.0f),	XMFLOAT2(5.0f, 5.0f), XMFLOAT3(0.0f, -1.0f, 0.0f) },
		{ XMFLOAT3(1.0f, 1.0f, 0.0f),	XMFLOAT3(1.0f, 1.0f, 0.0f),		XMFLOAT2(5.0f, 0.0f), XMFLOAT3(1.0f, 0.0f, 0.0f) },
		{ XMFLOAT3(-1.0f, 1.0f, 0.0f),	XMFLOAT3(-1.0f, 1.0f, 0.0f),	XMFLOAT2(0.0f, 0.0f), XMFLOAT3(0.0f, 1.0f, 0.0f) }
	};

	ZeroMemory(&bd, sizeof(bd));
	bd.Usage = D3D11_USAGE_DEFAULT;
	bd.ByteWidth = sizeof(SimpleVertex) * 4;
	bd.BindFlags = D3D11_BIND_VERTEX_BUFFER;
	bd.CPUAccessFlags = 0;

	ZeroMemory(&InitData, sizeof(InitData));
	InitData.pSysMem = planeVertices;

	hr = _pd3dDevice->CreateBuffer(&bd, &InitData, &_pPlaneVertexBuffer);

	if (FAILED(hr))
		return hr;

#pragma endregion

	return S_OK;
}

HRESULT DX11AppHelper::InitIndexBuffer()
{
	HRESULT hr;

	// Create index buffer
	WORD indices[] =
	{
		3, 1, 0,
		2, 1, 3,

		6, 4, 5,
		7, 4, 6,

		11, 9, 8,
		10, 9, 11,

		14, 12, 13,
		15, 12, 14,

		19, 17, 16,
		18, 17, 19,

		22, 20, 21,
		23, 20, 22
	};

	D3D11_BUFFER_DESC bd;
	ZeroMemory(&bd, sizeof(bd));

	bd.Usage = D3D11_USAGE_DEFAULT;
	bd.ByteWidth = sizeof(WORD) * 36;
	bd.BindFlags = D3D11_BIND_INDEX_BUFFER;
	bd.CPUAccessFlags = 0;

	D3D11_SUBRESOURCE_DATA InitData;
	ZeroMemory(&InitData, sizeof(InitData));
	InitData.pSysMem = indices;
	hr = _pd3dDevice->CreateBuffer(&bd, &InitData, &_pIndexBuffer);

	if (FAILED(hr))
		return hr;

	// Create plane index buffer
	WORD planeIndices[] =
	{
		0, 3, 1,
		3, 2, 1,
	};

	ZeroMemory(&bd, sizeof(bd));
	bd.Usage = D3D11_USAGE_DEFAULT;
	bd.ByteWidth = sizeof(WORD) * 6;
	bd.BindFlags = D3D11_BIND_INDEX_BUFFER;
	bd.CPUAccessFlags = 0;

	ZeroMemory(&InitData, sizeof(InitData));
	InitData.pSysMem = planeIndices;
	hr = _pd3dDevice->CreateBuffer(&bd, &InitData, &_pPlaneIndexBuffer);

	if (FAILED(hr))
		return hr;

	return S_OK;
}

HRESULT DX11AppHelper::InitConstantBuffers()
{
	HRESULT hr;

	// Create the constant buffer
	D3D11_BUFFER_DESC bd;
	ZeroMemory(&bd, sizeof(bd));
	bd.Usage = D3D11_USAGE_DEFAULT;
	bd.ByteWidth = sizeof(ConstantBuffer);
	bd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	bd.CPUAccessFlags = 0;
	hr = _pd3dDevice->CreateBuffer(&bd, nullptr, &_pConstantBuffer);

	if (FAILED(hr))
		return hr;

	// Create the shadow map constant buffer
	ZeroMemory(&bd, sizeof(bd));
	bd.Usage = D3D11_USAGE_DEFAULT;
	bd.ByteWidth = sizeof(SMConstantBuffer);
	bd.BindFlags = D3D11_BIND_CONSTANT_BUFFER;
	bd.CPUAccessFlags = 0;
	hr = _pd3dDevice->CreateBuffer(&bd, nullptr, &_pSMConstantBuffer);

	if (FAILED(hr))
		return hr;

	if (FAILED(hr))
		return hr;
}

HRESULT DX11AppHelper::InitRasterizerState()
{
	HRESULT hr;

	// Rasterizer
	D3D11_RASTERIZER_DESC cmdesc;

	ZeroMemory(&cmdesc, sizeof(D3D11_RASTERIZER_DESC));
	cmdesc.FillMode = D3D11_FILL_SOLID;
	cmdesc.CullMode = D3D11_CULL_NONE;
	hr = _pd3dDevice->CreateRasterizerState(&cmdesc, &_pRSCullNone);

	if (FAILED(hr))
		return hr;

	D3D11_DEPTH_STENCIL_DESC dssDesc;
	ZeroMemory(&dssDesc, sizeof(D3D11_DEPTH_STENCIL_DESC));
	dssDesc.DepthEnable = true;
	dssDesc.DepthWriteMask = D3D11_DEPTH_WRITE_MASK_ALL;
	dssDesc.DepthFunc = D3D11_COMPARISON_LESS_EQUAL;

	_pd3dDevice->CreateDepthStencilState(&dssDesc, &_pDSLessEqual);

	ZeroMemory(&cmdesc, sizeof(D3D11_RASTERIZER_DESC));

	cmdesc.FillMode = D3D11_FILL_SOLID;
	cmdesc.CullMode = D3D11_CULL_BACK;

	cmdesc.FrontCounterClockwise = true;
	hr = _pd3dDevice->CreateRasterizerState(&cmdesc, &_pCCWcullMode);

	if (FAILED(hr))
		return hr;

	cmdesc.FrontCounterClockwise = false;
	hr = _pd3dDevice->CreateRasterizerState(&cmdesc, &_pCWcullMode);
	return S_OK;

	return hr;
}

void DX11AppHelper::Cleanup()
{
#pragma region DirectX Initialisation Variables

	if (_pSwapChain) _pSwapChain->Release();
	if (_pImmediateContext) _pImmediateContext->ClearState();
	if (_pImmediateContext) _pImmediateContext->Release();
	if (DX11AppHelper::_pd3dDevice)  DX11AppHelper::_pd3dDevice->Release();

#pragma endregion

#pragma region Rasterizer States

	if (_pDSLessEqual) _pDSLessEqual->Release();
	if (_pRSCullNone) _pRSCullNone->Release();

	if (_pCCWcullMode) _pCCWcullMode->Release();
	if (_pCWcullMode) _pCWcullMode->Release();

#pragma endregion

#pragma region Buffer Variables

	if (_pVertexBuffer) _pVertexBuffer->Release();
	if (_pIndexBuffer) _pIndexBuffer->Release();

	if (_pPlaneVertexBuffer) _pPlaneVertexBuffer->Release();
	if (_pPlaneIndexBuffer) _pPlaneIndexBuffer->Release();

	if (_pConstantBuffer) _pConstantBuffer->Release();
	if (_pSMConstantBuffer) _pSMConstantBuffer->Release();

#pragma endregion
}